# HTTP Server Implementation Guide

## Table of Contents
1. [Introduction to HTTP and Web Servers](#1-introduction-to-http-and-web-servers)
2. [HTTP Protocol Fundamentals](#2-http-protocol-fundamentals)
3. [HTTP Server Architecture](#3-http-server-architecture)
4. [Implementing Your HTTP Server](#4-implementing-your-http-server)
5. [Configuration File Implementation](#5-configuration-file-implementation)
6. [Testing and Validation](#6-testing-and-validation)
7. [Common Challenges and Solutions](#7-common-challenges-and-solutions)
8. [Appendix: HTTP Status Codes](#8-appendix-http-status-codes)

## 1. Introduction to HTTP and Web Servers

### 1.1 What is HTTP?

The **Hypertext Transfer Protocol (HTTP)** is an application-level protocol designed for distributed, collaborative, hypermedia information systems. It serves as the foundation of data communication for the World Wide Web.

HTTP operates on a client-server model: a client (usually a web browser) sends requests to a server, which processes these requests and returns appropriate responses. This stateless protocol allows information to be transferred between clients and servers as hypertext documents, supporting the linked nature of the web.

### 1.2 Role of a Web Server

A web server's primary function is to:
- Store, process, and deliver web pages to clients
- Handle multiple concurrent connections from clients
- Process different types of requests (GET, POST, etc.)
- Serve appropriate content based on the request
- Manage errors and exceptional situations
- Execute server-side applications when needed (CGI)

### 1.3 Evolution of HTTP

- **HTTP/0.9**: Simple, supporting only GET method and HTML responses
- **HTTP/1.0**: Added headers, status codes, and content types
- **HTTP/1.1**: Introduced persistent connections, chunked transfers, and more methods
- **HTTP/2**: Binary protocol with multiplexing and header compression
- **HTTP/3**: Based on QUIC protocol using UDP instead of TCP

Your implementation will focus on HTTP/1.1 compliant behavior.

## 2. HTTP Protocol Fundamentals

### 2.1 HTTP Message Structure

#### Request Message:
```
[Method] [Request-URI] [HTTP-Version]
[headers]

[message body]
```

Example:
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml
```

#### Response Message:
```
[HTTP-Version] [Status-Code] [Reason-Phrase]
[headers]

[message body]
```

Example:
```
HTTP/1.1 200 OK
Date: Mon, 23 May 2023 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 138

<!DOCTYPE html>
<html>
<head>
  <title>Example Page</title>
</head>
<body>
  <h1>Hello, World!</h1>
</body>
</html>
```

### 2.2 HTTP Methods

- **GET**: Retrieve data from the server
- **POST**: Submit data to be processed
- **HEAD**: Like GET but returns only headers (no body)
- **PUT**: Upload a resource to replace the current one
- **DELETE**: Remove a specified resource
- **OPTIONS**: Get supported methods for a resource
- **TRACE**: Echo the received request for debugging

Your implementation must support at least GET, POST, and DELETE.

### 2.3 HTTP Headers

HTTP headers provide additional information about the request or response. Common headers include:

#### Request Headers:
- `Host`: Domain name of the server
- `User-Agent`: Client software identification
- `Accept`: Media types the client can process
- `Content-Type`: Media type of the request body
- `Content-Length`: Size of the request body
- `Connection`: Control options for the connection

#### Response Headers:
- `Date`: Timestamp when the response was generated
- `Server`: Software used by the server
- `Content-Type`: Media type of the response body
- `Content-Length`: Size of the response body
- `Last-Modified`: Last modification time of the resource

### 2.4 Request Processing Flow

1. Client opens a connection to the server
2. Client sends a request message
3. Server processes the request
4. Server returns a response
5. Connection is maintained (HTTP/1.1) or closed

## 3. HTTP Server Architecture

### 3.1 Non-Blocking I/O

A non-blocking server can handle multiple connections without using separate threads or processes for each connection. This is achieved by:

1. Setting socket file descriptors to non-blocking mode
2. Using I/O multiplexing to monitor multiple descriptors
3. Processing only the ready descriptors without blocking on any single one

### 3.2 I/O Multiplexing

Your server must use one of the following functions for I/O multiplexing:

- **poll()**: Monitor multiple file descriptors for events
- **select()**: Similar to poll but with a different interface
- **kqueue()**: High-performance event notification (BSD/macOS)
- **epoll()**: Linux-specific high-performance event notification

Example using poll():

```cpp
struct pollfd fds[MAX_CONNECTIONS];
// Setup fds array with socket descriptors to monitor
int ret = poll(fds, nfds, timeout);
if (ret > 0) {
    // Process ready descriptors
    for (int i = 0; i < nfds; i++) {
        if (fds[i].revents & POLLIN) {
            // Ready for reading
            process_read(fds[i].fd);
        }
        if (fds[i].revents & POLLOUT) {
            // Ready for writing
            process_write(fds[i].fd);
        }
    }
}
```

### 3.3 Connection Management

Your server must:
- Listen on configured ports
- Accept new connections
- Monitor active connections for read/write readiness
- Handle timeouts and disconnections
- Properly close connections when needed

### 3.4 CGI Execution

Common Gateway Interface (CGI) allows the server to execute external programs and incorporate their output in responses.

For CGI handling:
1. Fork a child process
2. Set up environment variables (PATH_INFO, REQUEST_METHOD, etc.)
3. Redirect stdin/stdout as needed
4. Execute the CGI program
5. Read CGI output and send it to the client
6. Handle chunked encoding if necessary

## 4. Implementing Your HTTP Server

### 4.1 Basic Components

Your HTTP server implementation should include:

1. **Socket Management**: Creating, binding, and listening on sockets
2. **Connection Handling**: Accepting and managing client connections
3. **Request Parsing**: Breaking down and validating HTTP requests
4. **Request Processing**: Handling different HTTP methods
5. **Response Generation**: Creating appropriate HTTP responses
6. **File Handling**: Serving static files from the filesystem
7. **Error Handling**: Generating appropriate error responses
8. **Configuration**: Reading and applying server configuration

### 4.2 Code Structure Example

```cpp
// Main server class
class HttpServer {
private:
    std::vector<ServerConfig> configs;
    std::map<int, Connection> connections;
    
    void initialize_server();
    void handle_new_connection();
    void process_ready_descriptors();
    void handle_client_request(Connection& conn);
    void generate_response(Connection& conn, Request& req);
    
public:
    HttpServer(const std::string& config_file);
    void run();
};

// Request parser
class RequestParser {
public:
    bool parse(const std::string& raw_request, Request& req);
    // ...
};

// Response generator
class ResponseGenerator {
public:
    void generate(const Request& req, Response& res, const ServerConfig& config);
    // ...
};
```

### 4.3 Project Requirements

Your implementation must meet these core requirements:

1. **Written in C++98**
2. **Non-blocking I/O operations**
3. **Use of poll() or equivalent for I/O multiplexing**
4. **Support for configurable server settings**
5. **Support for GET, POST, and DELETE HTTP methods**
6. **Serving static websites**
7. **Handling file uploads**
8. **CGI support**
9. **Proper error handling with accurate status codes**
10. **Default error pages**

### 4.4 Forbidden Practices

Avoid these practices in your implementation:

1. **Using blocking I/O operations**
2. **Checking errno after read/write operations**
3. **Executing another web server (no execve of another server)**
4. **Using fork except for CGI execution**
5. **Using external libraries (except standard C/C++ libraries)**

## 5. Configuration File Implementation

### 5.1 Configuration File Format

Your server should support a configuration file similar to NGINX's format. Example:

```
server {
    listen 8080;
    server_name example.com;
    error_page 404 /html/htmlError/404.html;
    client_max_body_size 10M;
    
    location / {
        root /var/www/html;
        index index.html;
        methods GET POST;
        autoindex on;
    }
    
    location /uploads {
        root /var/www/uploads;
        methods POST DELETE;
        upload_store /var/www/uploads;
    }
    
    location ~ \.php$ {
        root /var/www/php;
        cgi_pass /usr/bin/php-cgi;
        methods GET POST;
    }
}

server {
    listen 8081;
    server_name api.example.com;
    # ...
}
```

### 5.2 Configuration Parameters

Your server should support these configuration parameters:

1. **Server Level:**
   - **listen**: Port number
   - **server_name**: Server identification
   - **error_page**: Custom error pages
   - **client_max_body_size**: Maximum request body size

2. **Location Level:**
   - **root**: Document root directory
   - **index**: Default file for directory requests
   - **methods**: Allowed HTTP methods
   - **autoindex**: Directory listing (on/off)
   - **redirect**: HTTP redirection
   - **cgi_pass**: CGI processor path
   - **upload_store**: Upload destination

### 5.3 Parsing Configuration

Implement a robust parser for your configuration file:

1. Read the file line by line
2. Tokenize and validate syntax
3. Build a hierarchical representation of the configuration
4. Apply default values for unspecified parameters
5. Detect and report configuration errors

## 6. Testing and Validation

### 6.1 Manual Testing

1. **Use telnet or curl** to send raw HTTP requests
   ```bash
   telnet localhost 8080
   GET / HTTP/1.1
   Host: localhost
   ```

2. **Test with web browsers** to verify compatibility
   - Chrome, Firefox, Safari, etc.
   - Test navigation, forms, file uploads

3. **Compare with NGINX** for reference behavior

### 6.2 Automated Testing

Create test scripts to verify:

1. **HTTP method handling**: GET, POST, DELETE
2. **Status code accuracy**: All returned status codes
3. **Header handling**: Required and optional headers
4. **Content serving**: Text, binary, and large files
5. **Edge cases**: Malformed requests, large payloads, etc.

### 6.3 Stress Testing

Verify server stability under load:

1. **Concurrent connections**: Handle multiple simultaneous clients
2. **High request rates**: Process requests rapidly
3. **Resource management**: Proper release of resources
4. **Recovery**: Maintain stability after connection issues

Tools like Apache Benchmark (ab) or wrk can help with stress testing.

## 7. Common Challenges and Solutions

### 7.1 Memory Management

**Challenge**: Resource leaks during extended operation
**Solution**: 
- Careful tracking of all allocated resources
- Use of RAII (Resource Acquisition Is Initialization) pattern
- Regular testing for memory leaks

### 7.2 Persistent Connections

**Challenge**: Managing many open connections efficiently
**Solution**:
- Proper implementation of connection timeouts
- Careful tracking of connection state
- Efficient I/O monitoring

### 7.3 Request Parsing Edge Cases

**Challenge**: Handling malformed or unusual requests
**Solution**:
- Robust parsing with proper error handling
- Strict validation of request components
- Appropriate error responses

### 7.4 CGI Security

**Challenge**: Safely executing external programs
**Solution**:
- Input sanitization
- Resource limitations
- Proper permission settings
- Timeout handling

### 7.5 File Upload Handling

**Challenge**: Securely managing uploaded files
**Solution**:
- Size restrictions
- Type validation
- Secure storage paths
- Temporary file management

## 8. Appendix: HTTP Status Codes

### 1xx: Informational
- **100 Continue**: Server has received the request headers
- **101 Switching Protocols**: Server is switching protocols

### 2xx: Success
- **200 OK**: Request succeeded
- **201 Created**: Request succeeded and resource created
- **204 No Content**: Request succeeded but no content returned

### 3xx: Redirection
- **301 Moved Permanently**: Resource has been moved permanently
- **302 Found**: Resource temporarily resides at another location
- **304 Not Modified**: Resource has not been modified since last request

### 4xx: Client Error
- **400 Bad Request**: Server cannot process the request
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Server refuses to fulfill the request
- **404 Not Found**: Requested resource not found
- **405 Method Not Allowed**: Method not supported for the resource
- **413 Payload Too Large**: Request entity too large
- **414 URI Too Long**: Request-URI too long

### 5xx: Server Error
- **500 Internal Server Error**: Generic server error
- **501 Not Implemented**: Server does not support the functionality
- **502 Bad Gateway**: Invalid response from upstream server
- **503 Service Unavailable**: Server temporarily unavailable
- **504 Gateway Timeout**: Upstream server did not respond in time
- **505 HTTP Version Not Supported**: Server does not support HTTP version
