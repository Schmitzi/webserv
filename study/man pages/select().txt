NAME         

       select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO, fd_set -
       synchronous I/O multiplexing

LIBRARY         

       Standard C library (libc, -lc)

SYNOPSIS         

       #include <sys/select.h>

       typedef /* ... */ fd_set;

       int select(int nfds, fd_set *_Nullable restrict readfds,
                  fd_set *_Nullable restrict writefds,
                  fd_set *_Nullable restrict exceptfds,
                  struct timeval *_Nullable restrict timeout);

       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);

       int pselect(int nfds, fd_set *_Nullable restrict readfds,
                  fd_set *_Nullable restrict writefds,
                  fd_set *_Nullable restrict exceptfds,
                  const struct timespec *_Nullable restrict timeout,
                  const sigset_t *_Nullable restrict sigmask);

   Feature Test Macro Requirements for glibc (see
   feature_test_macros(7)):

       pselect():
           _POSIX_C_SOURCE >= 200112L

DESCRIPTION         

       WARNING: select() can monitor only file descriptors numbers that
       are less than FD_SETSIZE (1024)—an unreasonably low limit for
       many modern applications—and this limitation will not change.
       All modern applications should instead use poll(2) or epoll(7),
       which do not suffer this limitation.

       select() allows a program to monitor multiple file descriptors,
       waiting until one or more of the file descriptors become "ready"
       for some class of I/O operation (e.g., input possible).  A file
       descriptor is considered ready if it is possible to perform a
       corresponding I/O operation (e.g., read(2), or a sufficiently
       small write(2)) without blocking.

   fd_set
       A structure type that can represent a set of file descriptors.
       According to POSIX, the maximum number of file descriptors in an
       fd_set structure is the value of the macro FD_SETSIZE.

   File descriptor sets
       The principal arguments of select() are three "sets" of file
       descriptors (declared with the type fd_set), which allow the
       caller to wait for three classes of events on the specified set
       of file descriptors.  Each of the fd_set arguments may be
       specified as NULL if no file descriptors are to be watched for
       the corresponding class of events.

       Note well: Upon return, each of the file descriptor sets is
       modified in place to indicate which file descriptors are
       currently "ready".  Thus, if using select() within a loop, the
       sets must be reinitialized before each call.

       The contents of a file descriptor set can be manipulated using
       the following macros:

       FD_ZERO()
              This macro clears (removes all file descriptors from) set.
              It should be employed as the first step in initializing a
              file descriptor set.

       FD_SET()
              This macro adds the file descriptor fd to set.  Adding a
              file descriptor that is already present in the set is a
              no-op, and does not produce an error.

       FD_CLR()
              This macro removes the file descriptor fd from set.
              Removing a file descriptor that is not present in the set
              is a no-op, and does not produce an error.

       FD_ISSET()
              select() modifies the contents of the sets according to
              the rules described below.  After calling select(), the
              FD_ISSET() macro can be used to test if a file descriptor
              is still present in a set.  FD_ISSET() returns nonzero if
              the file descriptor fd is present in set, and zero if it
              is not.

   Arguments
       The arguments of select() are as follows:

       readfds
              The file descriptors in this set are watched to see if
              they are ready for reading.  A file descriptor is ready
              for reading if a read operation will not block; in
              particular, a file descriptor is also ready on end-of-
              file.

              After select() has returned, readfds will be cleared of
              all file descriptors except for those that are ready for
              reading.

       writefds
              The file descriptors in this set are watched to see if
              they are ready for writing.  A file descriptor is ready
              for writing if a write operation will not block.  However,
              even if a file descriptor indicates as writable, a large
              write may still block.

              After select() has returned, writefds will be cleared of
              all file descriptors except for those that are ready for
              writing.

       exceptfds
              The file descriptors in this set are watched for
              "exceptional conditions".  For examples of some
              exceptional conditions, see the discussion of POLLPRI in
              poll(2).

              After select() has returned, exceptfds will be cleared of
              all file descriptors except for those for which an
              exceptional condition has occurred.

       nfds   This argument should be set to the highest-numbered file
              descriptor in any of the three sets, plus 1.  The
              indicated file descriptors in each set are checked, up to
              this limit (but see BUGS).

       timeout
              The timeout argument is a timeval structure (shown below)
              that specifies the interval that select() should block
              waiting for a file descriptor to become ready.  The call
              will block until either:

              •  a file descriptor becomes ready;

              •  the call is interrupted by a signal handler; or

              •  the timeout expires.

              Note that the timeout interval will be rounded up to the
              system clock granularity, and kernel scheduling delays
              mean that the blocking interval may overrun by a small
              amount.

              If both fields of the timeval structure are zero, then
              select() returns immediately.  (This is useful for
              polling.)

              If timeout is specified as NULL, select() blocks
              indefinitely waiting for a file descriptor to become
              ready.

   pselect()
       The pselect() system call allows an application to safely wait
       until either a file descriptor becomes ready or until a signal is
       caught.

       The operation of select() and pselect() is identical, other than
       these three differences:

       •  select() uses a timeout that is a struct timeval (with seconds
          and microseconds), while pselect() uses a struct timespec
          (with seconds and nanoseconds).

       •  select() may update the timeout argument to indicate how much
          time was left.  pselect() does not change this argument.

       •  select() has no sigmask argument, and behaves as pselect()
          called with NULL sigmask.

       sigmask is a pointer to a signal mask (see sigprocmask(2)); if it
       is not NULL, then pselect() first replaces the current signal
       mask by the one pointed to by sigmask, then does the "select"
       function, and then restores the original signal mask.  (If
       sigmask is NULL, the signal mask is not modified during the
       pselect() call.)

       Other than the difference in the precision of the timeout
       argument, the following pselect() call:

           ready = pselect(nfds, &readfds, &writefds, &exceptfds,
                           timeout, &sigmask);

       is equivalent to atomically executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);
           ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);
           pthread_sigmask(SIG_SETMASK, &origmask, NULL);

       The reason that pselect() is needed is that if one wants to wait
       for either a signal or for a file descriptor to become ready,
       then an atomic test is needed to prevent race conditions.
       (Suppose the signal handler sets a global flag and returns.  Then
       a test of this global flag followed by a call of select() could
       hang indefinitely if the signal arrived just after the test but
       just before the call.  By contrast, pselect() allows one to first
       block signals, handle the signals that have come in, then call
       pselect() with the desired sigmask, avoiding the race.)

   The timeout
       The timeout argument for select() is a structure of the following
       type:

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

       The corresponding argument for pselect() is a timespec(3)
       structure.

       On Linux, select() modifies timeout to reflect the amount of time
       not slept; most other implementations do not do this.  (POSIX.1
       permits either behavior.)  This causes problems both when Linux
       code which reads timeout is ported to other operating systems,
       and when code is ported to Linux that reuses a struct timeval for
       multiple select()s in a loop without reinitializing it.  Consider
       timeout to be undefined after select() returns.

RETURN VALUE         

       On success, select() and pselect() return the number of file
       descriptors contained in the three returned descriptor sets (that
       is, the total number of bits that are set in readfds, writefds,
       exceptfds).  The return value may be zero if the timeout expired
       before any file descriptors became ready.

       On error, -1 is returned, and errno is set to indicate the error;
       the file descriptor sets are unmodified, and timeout becomes
       undefined.

ERRORS         

       EBADF  An invalid file descriptor was given in one of the sets.
              (Perhaps a file descriptor that was already closed, or one
              on which an error has occurred.)  However, see BUGS.

       EINTR  A signal was caught; see signal(7).

       EINVAL nfds is negative or exceeds the RLIMIT_NOFILE resource
              limit (see getrlimit(2)).

       EINVAL The value contained within timeout is invalid.

       ENOMEM Unable to allocate memory for internal tables.

